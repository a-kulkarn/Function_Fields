# -*- coding: utf-8 -*-
# This file was *autogenerated* from the file lib/plusidealsFF.sage
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4)
import pprint
from itertools import product
pp = pprint.PrettyPrinter(indent=_sage_const_4 )




def is_prime_polynomial(g):
	"""
	Returns True if g is a prime polynomial, and False otherwise
	"""
	fac=factor(g)
	if len(list(fac)) == _sage_const_1  and fac[_sage_const_0 ][_sage_const_1 ] == _sage_const_1 :
		return True
	else:
		return False	




def ab_slope(a, b, cloud):
    return QQ(cloud[b][_sage_const_1 ]-cloud[a][_sage_const_1 ])/QQ(cloud[b][_sage_const_0 ]-cloud[a][_sage_const_0 ])

def lower_convex_hull(cloud):
    """
    Computes the lower convex hull of a cloud of points.
    """
    # Special case where our cloud is a single point.
    if len(cloud) == _sage_const_1 :
        return [ Side(_sage_const_0 , list2point(cloud[_sage_const_0 ]), list2point(cloud[_sage_const_0 ])) ]

    slopes = [ [_sage_const_0 , _sage_const_1 , ab_slope(_sage_const_0 , _sage_const_1 , cloud)] ]
    b = _sage_const_2 
    while b < len(cloud):
        for i in (ellipsis_range(_sage_const_0 ,Ellipsis,len(slopes)-_sage_const_1 )):
            a = slopes[i][_sage_const_0 ]
            slope = ab_slope(a, b, cloud)
            if slope <= slopes[i][_sage_const_2 ]:
                slopes = slopes[_sage_const_0 :i]
                slopes.append([a, b, slope])
                break
        if slopes[-_sage_const_1 ][_sage_const_1 ] != b:
            a = b - _sage_const_1 
            slope = ab_slope(a, b, cloud)
            slopes.append([a, b, slope])
        b += _sage_const_1 

    slopes = [ Side(slope, list2point(cloud[a]), list2point(cloud[b])) for a, b, slope in slopes ]
    return slopes

def list2point(l):
    return Point(l[_sage_const_0 ], l[_sage_const_1 ])

class Point(object):

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __unicode__(self):
        return '(%d, %d)' % (self.x, self.y,)

    def __repr__(self):
        return self.__unicode__()

    def list(self):
        return [self.x, self.y]

class Side(object):

    def __init__(self, slope, p1, p2):
        self.slope = slope
        self.p1 = p1
        self.p2 = p2

    def __unicode__(self):
        return '[%s, %s, %s]' % (unicode(self.slope), unicode(self.p1), unicode(self.p2),)

    def __repr__(self):
        return self.__unicode__()

    def width(self):
        return self.p2.x - self.p1.x 
    
    def height(self):
        return self.p1.y - self.p2.y

class MontesType(object):

    def __init__(self, F, p, varphi, omega, initial=True):
        self.parent = F
        self.pol = minimal_polynomial(F.gen(0))
        self.prime = p
        self.varphi = varphi        
        self.levels = [ ]
        self.sfl = [_sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 ] # Single Factor Lifting
        self.phiadic = [F.base_field()(_sage_const_0 ) for i in range(_sage_const_0 , _sage_const_4 )]	 
        self.res_class_field = FiniteField(len(p.parent().base_ring())**p.degree(),conway=True,prefix='zini')


        if initial is True:
            self.add_initial_level(varphi, omega, p)
    
    def copy(self):
        copy = MontesType(self.parent, self.prime, self.varphi,
                          self.levels[_sage_const_0 ].omega, initial=False)

        for level in self.levels:
            copy.levels.append(level.copy())
        
        return copy

    def add_initial_level(self, varphi, omega, p):
        phi = self.pol.parent()(varphi)
        new_level = MontesTypeLevel(phi, omega, p)
        q = len(p.parent().base_ring())**(p.degree()*varphi.degree())
#        print"mal sehen inadd_ini "  ,q		
	
        new_level.Fq = FiniteField(q, name='z0',
                                   conway=True, prefix='ww')
                                    
        new_level.z = new_level.Fq.gen(0)
        new_level.Fqy = PolynomialRing(new_level.Fq, 'y0')
        new_level.inv_M = matrix([])

        self.levels.append(new_level)

    def add_new_level(self, phi, omega, u):
        s = len(self.levels)
        lvl_s = self.levels[-_sage_const_1 ]
        new_level = MontesTypeLevel(phi, omega, self.prime)
        new_level.V = lvl_s.e*u
        new_level.prod_e = lvl_s.prod_e * lvl_s.e
        new_level.prod_f = lvl_s.prod_f * lvl_s.f        
        
        q=(len(self.prime.parent().base_ring())**self.prime.degree())**new_level.prod_f
      
        new_level.Fq = FiniteField(q, name='w'+str(s),
                                   conway=True, prefix='ww')
 #       print"mal sehen "  ,new_level.Fq 
        new_level.Fqy = PolynomialRing(new_level.Fq, 'y'+str(s))
        #new_level.embedding = Hom(lvl_s.Fq, new_level.Fq).list()[0]
         
        if lvl_s.f > _sage_const_1 :
            
            lifted_res_pol = new_level.Fqy(
                    [new_level.Fq(c) for c in lvl_s.res_pol])

            # Take the first root of the residual polynomial in the new
            # level's Fq[y].
            new_level.z = lifted_res_pol.roots()[_sage_const_0 ][_sage_const_0 ]
            M = matrix([vector(new_level.z**j * lvl_s.Fq.gen()**k)
                        for j in range(lvl_s.f)
                        for k in range(lvl_s.prod_f)])
            new_level.inv_M = M**(-_sage_const_1 )
        else:
            new_level.z = -list(lvl_s.res_pol)[_sage_const_0 ]
            new_level.inv_M = lvl_s.inv_M

        self.levels.append(new_level)
        return new_level

    def refinement(self, more_factors=False):
        r = len(self.levels) - _sage_const_1 
        if more_factors is True:
            self.lvl(r).refinements.append([self.lvl(r).phi,
                                            self.lvl(r).slope])
        self.lvl(r).cutting_slope = ZZ(self.lvl(r+_sage_const_1 ).slope)
        self.lvl(r).phi = self.lvl(r+_sage_const_1 ).phi
        self.lvl(r).omega = self.lvl(r+_sage_const_1 ).omega

        self.remove_last_level()

    def add_last_level(self, phiadic, side, side_dev, last_psi=True):
        #tt.add_last_level(phiadic, sides[0], side_devs)

        r = len(self.levels)
        lvl_r = self.lvl(r)
        lvl_r.e = _sage_const_1 
        if r > _sage_const_1 :
            # FIXME: What does nur stand for?
            nur = sum([self.lvl(j).slope/self.lvl(j).prod_e for j in (ellipsis_range(_sage_const_1 ,Ellipsis,r-_sage_const_1 ))])
            self.sfl[_sage_const_0 ] = floor((lvl_r.V/lvl_r.prod_e)-nur)

        if side.p1.x == _sage_const_0 :
            slope = -side.slope
            lvl_r.h = ZZ(slope)
            # FIXME: Why do we just take the first 2 elements?
          
            self.phiadic[_sage_const_0 :_sage_const_2 ] = phiadic[_sage_const_0 :_sage_const_2 ]
            if last_psi:
  #              print"inside2",r, side_dev
                res_pol = self.residual_polynomial(r, side_dev)
   #             print "last monic res.pol. = %s (%s)" % (res_pol, res_pol.monic())

                lvl_r.res_pol = res_pol.monic()

                lvl_r.log_gamma = lvl_r.log_phi - (lvl_r.h * lvl_r.log_pi)
  
        else:
            slope = +Infinity
        lvl_r.slope = slope
        
        return lvl_r

    def remove_last_level(self):
        self.levels.pop()

    def lvl(self, i):
        ''' 1 indexed access to array levels.'''
        assert i > _sage_const_0 , 'tt.lvl(i) is 1 indexed, so i must be > 0.'
        return self.levels[i-_sage_const_1 ]

    def __unicode__(self):
        return '(%s; %s)' % (self.varphi,
                             '; '.join([unicode(l) for l in self.levels]))

    def __repr__(self):
        return self.__unicode__()

    def rth_level(self):
        return self.levels[-_sage_const_1 ]


    #### Begin serious Montes methods ####

    ## Phi-Newton Polygons ##
    def phi_newton_polygon(self, i, phiadic):
        assert i <= len(self.levels)

        n = _sage_const_0 
        sides = []
        cloud = []
        side_devs = []
        all_devs = []
        for k in (ellipsis_range(_sage_const_0 ,Ellipsis,len(phiadic)-_sage_const_1 )):
            val = _sage_const_0 
            dev = [ ]

            val, dev = self.value(i, phiadic[k])
            #print "N_%d : v_%d(%s phi_%d) = %s + %d" % (i, i, phiadic[k], i, str(val), n)
            if abs(val) != Infinity:
                cloud.append([k, val + n])
                all_devs.append(dev)
            n += self.lvl(i).V

    #    print "%d. cloud: %s" % (i, cloud,)
        sides = lower_convex_hull(cloud)
        abscissas = [ p[_sage_const_0 ] for p in cloud ]    

        for side in sides:
            height = ZZ(side.p1.y) # [1][1]
            dev = [ ]

            # [1][0], [2][0]
            for j in range(side.p1.x, side.p2.x + side.slope.denominator(), side.slope.denominator()):
                try:
                    position = abscissas.index(j)
                except ValueError:
                   position = -_sage_const_1  
                
                if position > -_sage_const_1  and cloud[position][_sage_const_1 ] == height:
                    dev.append(all_devs[position])
                elif i == _sage_const_1 :
                    dev.append(_sage_const_0 )
                else:
                    dev.append([])
                height += side.slope.numerator()
                
            dev.append(side.p1.list()) # list(side[1])
            side_devs.append(dev)    

        if len(sides) == _sage_const_0 :
            raise NotImplementedError, "Case for a zero side Newton Polygon has not been implemented"


        return sides, side_devs

    ## Value of polynomial a(x) in ZZ[x] ##
    def value(self, i, a):
        assert i <= len(self.levels)

        val = +Infinity
        if a == _sage_const_0 :
            if i == _sage_const_1 :
                devs = _sage_const_0 
            else:
                devs = []
            return val, devs

        if i == _sage_const_1 :
            val = min([valuation(c, self.prime) for c in list(a)])
            devs = a
        else:
            devs = []
            lvl_im1 = self.lvl(i-_sage_const_1 )
            step = lvl_im1.V + lvl_im1.slope
            min_height = _sage_const_0 
            V_height = _sage_const_0 
            quot = a
            k = _sage_const_0 
            last = _sage_const_0 

            while quot != _sage_const_0  and min_height < val:
                quot, ak = quot.quo_rem(lvl_im1.phi)
                new_val, dev = self.value(i-_sage_const_1 , ak)
                candidate = new_val + min_height
                if candidate <= val:
                    if candidate < val:
                        val = candidate
                        first_abscissa = k
                        first_ordinate = new_val + V_height
                        devs = [ dev ]
                    else:
                        for j in range(last+lvl_im1.e*_sage_const_2 , k+_sage_const_1 , lvl_im1.e):
                            if i-_sage_const_1  == _sage_const_1 :
                                devs.append(_sage_const_0 )
                            else:
                                devs.append([])
                        devs.append(dev)
                    last = k
                min_height += step
                V_height += lvl_im1.V
                k += _sage_const_1 
            # FIXME: Why are we so certain that first_abscissa and
            #        first_ordinate will have been set?
            devs.append([first_abscissa, first_ordinate])
            val = ZZ(lvl_im1.e * val)

        return val, devs

    ## Residual Polynomial ##
    def residual_polynomial(self, i, side_devs):
        """
        Creates and returns the i-th residual polynomial of a polynomial (f).
        side_devs is a list of the multiadic expansions of the coefficients of
        f whose attached points in N_r(f) lie on teh side S of slope
        -levels[i].slope. The last element of side_devs is [s, u], where s,u
        are the coordinates of the left end-point on S.
        """
        
        assert i <= len(self.levels)

        lvl_i = self.lvl(i)
       	p=self.lvl(_sage_const_1 ).prime.numerator()
        height = side_devs[-_sage_const_1 ][_sage_const_1 ]
        #print "height, side devs:", height, side_devs
        res_coeffs = [ ]
 #    	print"was is das",	i
        for dev in side_devs[:-_sage_const_1 ]:

            if (i == _sage_const_1  and dev == _sage_const_0 ) or (i > _sage_const_1  and len(dev) == _sage_const_0 ): 

                res_coeffs.append(lvl_i.Fq(_sage_const_0 ))
            elif i == _sage_const_1 :

                # coefficients are polynomials too."
#		print"in new0000"
                coeff = dev // self.prime**(height)
		
                k=self.lvl(_sage_const_1 ).Fq
                #k=self.res_class_field
                Fqy=self.lvl(_sage_const_1 ).Fqy
		
                if p.degree() > _sage_const_1 :
	                coeff=Fqy([k(list(ii.numerator() % p)) for ii in list(coeff)]) 
                            
                else:
	                coeff=Fqy([k(ii.numerator() % p) for ii in list(coeff)])                		                
 #           		print"in res pol for", coeff
                res_coeffs.append(coeff(lvl_i.z))
#                print"\n\n daten", dev, coeff,	coeff(lvl_i.z), lvl_i.z, lvl_i.z.parent()
                j = side_devs.index(dev)
		
                #print "%d. order Res.Pol. the easy way c_%d = (%d / %d) = %d (z_%d = %d)" % (i, j, dev, self.prime**height, dev // self.prime^(height), i-1, lvl_i.z)
            else:
		
                lvl_im1 = self.lvl(i-_sage_const_1 )
                twist_exp = (dev[-_sage_const_1 ][_sage_const_0 ] - lvl_im1.inv_h*height) // lvl_im1.e
                #print "%d. order Res.Pol. twist exp: %s" % (i, twist_exp,)
		
                # coefficients are polynomials too.
                coeff = self.residual_polynomial(i-_sage_const_1 , dev)
                lifted_coeff = lvl_i.Fqy([lvl_i.Fq(c) for c in coeff])
        #        print "------"
         #       print "coeff:", coeff, "parent:", coeff.parent()
          #      print "z:", lvl_i.z, "parent:", lvl_i.z.parent()
           #     print "------"
                res_coeffs.append(lvl_i.z**(twist_exp) * lifted_coeff(lvl_i.z))

                j = side_devs.index(dev)
                #print "%d. order Res.Pol. c_%d = %s (z_%d = %s)" % (
                #        i, j, lvl_i.z^(twist_exp)*coeff(lvl_i.z), i, lvl_i.z,)


            height = height - lvl_i.h
#        print"\n \n\n in res pol with coeff", res_coeffs 
        res_pol = lvl_i.Fqy(res_coeffs)
 #       print "%d. order Res.Pol = %s" % (i, res_pol,)

        return res_pol

    ## Representative ##
    def representative(self, omega):
        """
        Construct a representative phi of a type. A new level is added with
        phi and V.
        """

        s = len(self.levels)
        lvl_s = self.lvl(s)
        ef = lvl_s.e * lvl_s.f
        u = ef * lvl_s.V

        if s > _sage_const_1 :
            txp = -self.lvl(s-_sage_const_1 ).inv_h * (u // self.lvl(s-_sage_const_1 ).e)
            twist = lvl_s.z**(txp)
        else:
            twist = lvl_s.Fq(_sage_const_1 )

        # Reductum from magma
        res_pol = twist * lvl_s.Fqy(list(lvl_s.res_pol)[:-_sage_const_1 ])
  #      print "%s = %s * Reductum(%s) = %s * %s" % (res_pol, twist, lvl_s.res_pol, twist, lvl_s.Fqy(list(lvl_s.res_pol)[:-1]))
        u += lvl_s.f * lvl_s.h
        phi0 = self.construct(s, res_pol, _sage_const_0 , u)
   #     print "%d. Repr. = %s + phi^ef" % (s, phi0,)

        phi0 = phi0 + lvl_s.phi**(ef)
        new_level = self.add_new_level(phi0, omega, u)
        return new_level

    ## Construct ##
    def construct(self, i, res_pol, s, u):
        """
        This routine constructs a polynomial phi0 with integer coefficients
        such that:
          - deg phi0 < m_i + 1 and y^nu*R_i(phi0)(y) = res_pol(y), where
            nu = ord_y(res_pol).
          - The non-negative integers s,u are the coordinates of teh left
            endpoint of a segment of slope -lvl_i.slope supporting
            N_i(phi0)
        """
        assert i <= len(self.levels), "i (%d) must be <= #levels (%d)" % (i, len(self.levels),)
        lvl_i = self.lvl(i)
        assert res_pol.degree() < lvl_i.f, "res_pol is too large."
        assert u + s*lvl_i.slope >= lvl_i.f*(lvl_i.e*lvl_i.V + lvl_i.h), "the point (s, u) is too low"

        var = lvl_i.phi**(lvl_i.e)
        phi0 = _sage_const_0 
        height = u - res_pol.degree()*lvl_i.h
#        print "%d. Construct res.pol. coeffs: %s" % (i, unicode(list(reversed(list(res_pol)))),)
        if i == _sage_const_1 :
            for a in reversed(list(res_pol)):
                
                lift = self.pol.parent()(list(a.polynomial()))

                phi0 = (phi0 * var) + (lift * self.prime**height)
                height = height + lvl_i.h
        else:
            step = (lvl_i.e * lvl_i.V) + lvl_i.h
            new_V = u - (res_pol.degree() * step) - (s * lvl_i.V)
            lvl_im1 = self.lvl(i-_sage_const_1 )
            for a in reversed(list(res_pol)):
                # FIXME: What does pj stand for?
                pj = _sage_const_0 
                if a != _sage_const_0 :
                    txp, s_im1 = divmod(lvl_im1.inv_h*height, lvl_im1.e)
                    u_im1 = (new_V - (s_im1 * lvl_im1.h)) // lvl_im1.e
                    c = (a*lvl_i.z**txp)
                    # Doing the equivalent of (if Eltseq existed)
                    #         lvl_im1.Fqy(Eltseq(c, lvl_im1.Fq))
                    if c.parent().base_ring() == lvl_im1.Fq:
                        eltseq = list(c.polynomial())
                    else:
                        # FIXME: It may not be the most efficient way of doing
                        # this but it's pretty efficient for now. It is based
                        # on this answer:
                        # http://ask.sagemath.org/question/3398/representing-finite-field-elements-in-terms-of?answer=4540#4540
                        eltseq = None
                        w_im1 = lvl_im1.Fq.gen()
                        prod_f = lvl_im1.prod_f
                        m = vector(c) * lvl_i.inv_M
                        eltseq = [lvl_im1.Fq(m[j*prod_f:(j+_sage_const_1 )*prod_f])
                                   for j in range(len(m)/prod_f)]
                        if c != sum([eltseq[j]*lvl_i.z**j for j in range(len(eltseq))]):
                            raise(Exception,
                                 "Eltseq calculated incorrectly for {0}"\
                                         .format(c))

       #             print "%d.   Eltseq(%s, %s) = %s" % (i, c, lvl_im1.Fq, eltseq)
                    new_res_pol = lvl_im1.Fqy(eltseq)
                    pj = self.construct(i-_sage_const_1 , new_res_pol, s_im1, u_im1)
                phi0 = (phi0 * var) + pj
                new_V += step
                height += lvl_i.h

        phi0 = phi0 * lvl_i.phi**(s)
#        print "%d. Construct pol = %s" % (i, str(phi0))

        return phi0

    def single_factor_lifting(self, slope):
        """
        Perform single factor lifting on the representative of this type. The
        aim is to make self.rth_level().slope >= slope.
        """
        r = len(self.levels)
        lvl_r = self.rth_level()
        
        if lvl_r.slope >= slope:
            return
        if self.sfl[_sage_const_2 ] == _sage_const_0 :
            self.sfl_init()

        #print "SFL: {0} (slope: {1})".format(self.sfl, self.rth_level().slope)

        pmode = 'terse'
        p = self.prime
        exponent = self.sfl[_sage_const_0 ]
        nu = self.sfl[_sage_const_1 ]
        x0prec = self.sfl[_sage_const_2 ]
        x0num = self.phiadic[_sage_const_3 ]
        x0den = self.sfl[_sage_const_3 ]

        prod_e = lvl_r.prod_e
        h = lvl_r.h - lvl_r.cutting_slope
        last_h = slope - lvl_r.cutting_slope
        V = lvl_r.V + lvl_r.cutting_slope

        zp = Zp(p, nu + exponent + ceil((V+last_h)/prod_e), type='capped-abs',
                                                            print_mode=pmode)
        zpx = PolynomialRing(zp, 'X0')
        pol_zp = zpx(self.pol)
        psinum_zp = zpx(self.phiadic[_sage_const_2 ])

        path = path_of_precision(last_h, h)
        short_path = path_of_precision(h, x0prec)

        zp = Zp(p, nu + exponent + ceil(h/prod_e), type='capped-abs',
                                              print_mode=pmode)
        #print "That precision:", nu + exponent + ceil(h/prod_e);
        zpx = PolynomialRing(zp, 'X')
        a1 = zpx(self.phiadic[_sage_const_1 ])

        zq = Zp(p, nu + exponent + ceil((V+path[_sage_const_1 ])/prod_e), type='capped-abs',
                                                        print_mode=pmode)
        zqt = PolynomialRing(zq, names=('t',)); (t,) = zqt._first_ngens(1)
        phi = zqt(lvl_r.phi)
        psinum = zqt(psinum_zp)


        a0num, a0den = self.cancel((zqt(self.phiadic[_sage_const_0 ])*psinum) % phi, nu)
        print "a0 num, den:", [a0num, a0den]
        a1num, a1den = self.cancel((zqt(a1)*psinum) % phi, nu)
        print "a1 num, den:", [a1num, a1den]

        print "--==--==--==--==--==--==--"

        for i in range(_sage_const_1 , len(short_path)):
            low_precision = a1den + _sage_const_2  * x0den  + ceil(short_path[i]/prod_e)
            x0num, x0den = self.inversion_loop([ a1num, a1den], x0num, x0den,
                                               phi, low_precision)
            print "x0 num, den:", x0num, x0den
            print '----'

        print "--==--==--==--==--==--==--"

        anum, aden = self.cancel((a0num*zqt(x0num)) % phi, x0den+a0den)
        phi = phi + anum

        print "between:", [anum, aden, phi]
        print "--==--==--==--==--==--==--"

        for i in range(_sage_const_1 , len(path)-_sage_const_1 ):
            loop_prec = nu + exponent + ceil((V+path[i+_sage_const_1 ])/prod_e)
            print "Loop prec:", loop_prec;
            zq = Zp(p, loop_prec, type='capped-abs', print_mode=pmode)
            zqt = PolynomialRing(zq, names=('t',)); (t,) = zqt._first_ngens(1)
            phi = change_precision(zqt(phi), loop_prec)

            psinum = zqt(psinum_zp)
            qq, c0 = zqt(pol_zp).quo_rem(phi)

            c1 = qq % phi

            c0num, c0den = self.cancel((c0*psinum) % phi, nu)
            c1num, c1den = self.cancel((c1*psinum) % phi, nu)

            #print "cs:", [c1, c0num, c0den, c1num, c1den]

            low_precision = c1den + _sage_const_2  * x0den + ceil(path[i]/prod_e)
            x0num, x0den = self.inversion_loop([c1num, c1den], x0num, x0den,
                                               phi, low_precision)
            #print "x0 num, den", x0num, x0den

            xnum = change_precision(zqt(x0num), loop_prec)
            cnum, cden = self.cancel((c0num * zqt(x0num)) % phi, x0den)
            phi = phi + cnum

            print "phi:", phi
            print "--------------------------"


        print "--==--==--==--==--==--==--"

        self.sfl[_sage_const_2 ] = max(h, path[-_sage_const_2 ])
        lvl_r.phi = lvl_r.phi.parent()(phi)
        self.phiadic[_sage_const_3 ] = x0num
        self.sfl[_sage_const_3 ] = x0den

        
    def sfl_init(self):
        p = self.prime
        lvl_r = self.rth_level()
        prod_e = lvl_r.prod_e
        a1 = self.phiadic[_sage_const_1 ] # FIXME: Why [1]?
        Ax = PolynomialRing(p.numerator().parent(), names=('x',)); (x,) = Ax._first_ngens(1)
        psinum = Ax(_sage_const_1 )


        
        r = len(self.levels) - _sage_const_1 
        print"before class",r
        if r == _sage_const_0 :
            nu = min([valuation(a, p) for a in a1])
            # Evaluate a1/p^nu in z_1 (this may be z_0)
            klass = (a1 // p**nu)(self.lvl(_sage_const_1 ).z)
        else:
            val, dev = self.value(r+_sage_const_1 , a1)
            res_pol = self.residual_polynomial(r, dev)

            logpsi = _sage_const_0 
            qq, s = (-val).quo_rem(prod_e)
            psinum, logpsi = self.prescribed_value(s)

            nu = -logpsi[_sage_const_0 ] - qq
            vector = dev[-_sage_const_1 ][_sage_const_0 ] * self.lvl(r).log_phi + dev[-_sage_const_1 ][_sage_const_1 ]*self.lvl(r).log_pi
            klass = self.convert_logs(logpsi + vector)
            klass *= res_pol(self.lvl(r+_sage_const_1 ).z)

        self.phiadic[_sage_const_2 ] = psinum
        self.sfl[_sage_const_1 ] = nu
        self.sfl[_sage_const_2 ] = _sage_const_1 

        x0num = _sage_const_0 
        x0den = _sage_const_0 

        x0num, x0den = self.local_lift(klass**(-_sage_const_1 ))
        self.phiadic[_sage_const_3 ] = x0num
        self.sfl[_sage_const_3 ] = x0den

    def prescribed_value(self, value):
        """
        From +Ideals:
        If we are attached to the prime ideal P with Okutsu depth r, then
        logpsi=[a_0, ..., a_r] and psi=phi_1^a_1 ... phi_r^a_r, with
        v_P(p^a_0 psi(theta))=value.
        """
        psi = ZZ[x](_sage_const_1 )
        r = len(self.levels)
        logpsi = (ZZ**r)(_sage_const_0 )
        qq, val = value.quo_rem(self.rth_level().prod_e)
        logpsi[_sage_const_0 ] = qq
        if val > _sage_const_0 :
            body = val
            for k in reverse(range(r-_sage_const_2 )):
                jj = (self.levels[k].inv_h * body) % self.levels[k].e
                logpsi[k+_sage_const_1 ] = jj
                psi = psi * self.level[k].phi**jj
                res = (body - jj*self.levels[k].h) // self.levels[k].e
                body = res - jj*self.levels[k].V
            logpsi[_sage_const_0 ] += res

        return psi, logpsi

    def local_lift(self, clss):
        """
        From +Ideals:
        class should belong to the residue class field  type[r]`Fq. The output
        is a pair g,e such that g(theta)/p^e is a lift to a P-integral element
        in K and deg g(x)<n_P.
        """
        i = _sage_const_1 
        while clss not in self.lvl(i).Fq:
            i += _sage_const_1 

        if i == _sage_const_1 :
            numlift = ZZ[x](clss.polynomial())
            denlift = _sage_const_0 
        else:
            raise(NotImplemented, "local lift not implemented for i > 1.")

        return numlift, denlift

    def convert_logs(self, log):
        """"
        From +Ideals:
        log[1] is not used. The product of all Phi_i^log[i] for i>0 should have
        integer value M.

        The output is the class of this product divided by p^M.
        """

        vector = log
        z = _sage_const_0 
        klass = self.lvl(_sage_const_1 ).Fq.prime_subfield()(_sage_const_1 )
        for i in reversed(range(len(vector)-_sage_const_1 )):
            ti = vector[i+_sage_const_1 ] // self.levels[i].prod_e
            z = self.levels[i].z
            klass *= z**ti
            vector = vector - ti*self.levels[i].log_gamma

        return klass

    def cancel(self, poly, den):
        if poly == _sage_const_0 :
            return poly, _sage_const_0 

        cancel = min([den] + [ a.valuation(self.prime) for a in poly])
        zq = poly[_sage_const_0 ].parent()
        print "poly, p^cancel: {0}, p^{1}".format(poly, cancel)
        num = poly.parent()([ ZZ(c) / self.prime**cancel for c in poly ])
        print "num: {0}".format(num)
        #num = poly / self.prime^cancel

        return num, den-cancel

    def inversion_loop(self, A, xnum, xden, phi, precision):
        anum = A[_sage_const_0 ]
        aden = A[_sage_const_1 ]

        zq = Zp(self.prime, precision, type='capped-abs', print_mode='terse')
        zqt = PolynomialRing(zq, names=('t',)); (t,) = zqt._first_ngens(1)
        phip = zqt(phi)
        xnum = zqt(xnum)
        
        x1num, x1den = self.cancel(_sage_const_2 *self.prime**(xden+aden) - (zqt(anum)*xnum) % phip, xden+aden)
        xnum, xden = self.cancel((xnum*x1num) % phip, xden+x1den)

        return xnum, xden

class MontesTypeLevel(object):

    def __init__(self, phi, omega, p):
        self.phi = phi
        self.prime = p

        self.e = None
        self.f = None
        self.h = None
        self.prod_e = _sage_const_1 
        self.prod_f = _sage_const_1 
        self.inv_h = None

        self.V = _sage_const_0 
        self.omega = omega
        self.cutting_slope = _sage_const_0 
        self.refinements = [ ]

        self.log_pi = vector([_sage_const_1 , _sage_const_0 ])
        self.log_phi = vector([_sage_const_0 , _sage_const_1 ])
        self.log_gamma = None

        self.Fq = None
        self.z = None
        self.Fqy = None
        self.inv_M = None
        #self.embedding = None

        self.slope = None
        self.res_pol = None

    def copy(self):
        copy = MontesTypeLevel(self.phi, self.omega, self.prime)

        copy.phi = self.phi
        copy.prime = self.prime

        copy.e = self.e
        copy.f = self.f
        copy.h = self.h
        copy.prod_e = self.prod_e
        copy.prod_f = self.prod_f
        copy.inv_h = self.inv_h

        copy.V = self.V
        copy.omega = self.omega
        copy.cutting_slope = self.cutting_slope
        copy.refinements = self.refinements

        copy.log_pi = self.log_pi
        copy.log_phi = self.log_phi
        copy.log_gamma = self.log_gamma

        copy.Fq = self.Fq
        copy.z = self.z
        copy.Fqy = self.Fqy
        copy.inv_M = self.inv_M
        #copy.embedding = self.embedding

        copy.slope = self.slope
        copy.res_pol = self.res_pol

        return copy

    def __unicode__(self):
        phi = self.phi
        if self.slope is not None:
            slope = self.slope
        else:
            slope = '-'
        if self.res_pol is not None:
            res_pol = self.res_pol
        else:
            res_pol = '-'

        return '(%s, %s, %s)' % (str(phi), str(slope), str(res_pol))

    def __str__(self):
        return self.__unicode__()

    def __repr__(self):
        return self.__unicode__()

def montes(F, p, basis=False):

    if is_prime_polynomial(p) is False:
        raise Exception, "Error: p must be prime."

    f =minimal_polynomial(F.gen(0))					#K.defining_polynomial()
    if f.is_monic() is False:
    #sollte monic_integral_model verwenden um normiertes Polynom zu erzeugen
        raise Exception, "Error: def.pol. of F must be monic."
    # TODO: Add requirements that coefficients of f are integers



    reps_OM = [ ]
    trees = [ ]
    total_index=_sage_const_0 
    p=p.numerator()
    A=p.parent()

    F_0=FiniteField(len(A.base_ring())**p.degree(),conway=True,prefix='zini')
 
    F_0_y0=PolynomialRing(F_0, 'y0')
 
    if p.degree() > _sage_const_1 :
	    res_pol=F_0_y0([F_0(list(i.numerator() % p)) for i in list(f)])
    else:
		res_pol=F_0_y0([F_0(i.numerator() % p) for i in list(f)])
 

    for fac in res_pol.factor():

#	print "Analysing irred. factor modulo p: %s" % (str(factor[0]),)
        tt = MontesType(F, p, fac[_sage_const_0 ], fac[_sage_const_1 ])
        tree, tree_index = montes_main_loop(F, p, tt)
        total_index += tree_index
	
        reps_OM += tree
        trees.append(tree)

    if len(reps_OM) == _sage_const_1 :
        reps_OM[_sage_const_0 ].rth_level().phi = f
        reps_OM[_sage_const_0 ].rth_level().slope = +Infinity

   # print "OM Representatives:"
   # print len(reps_OM)
    #for tt in reps_OM:
    #    print "   ", tt
    
    
    	
   
    return reps_OM, total_index
    
def montes_main_loop(K, p, tt):
	    
    total_index = _sage_const_0 
    leaves = [ ]
    type_stack = [ tt ]
    while len(type_stack) > _sage_const_0 :
     #   print "STARTING LOOP:\n  type stack:", type_stack
        tt = type_stack.pop()

        r = len(tt.levels)
        lvl_r = tt.rth_level()
  
#        print "\n\n\nAnalysing type of order: %d (%s)"  % (r, unicode(lvl_r),)
       # print "--------------------------------------------------------------------------------\n"
	
        phiadic, quotients = phi_expansion(tt.pol,
                                           lvl_r.phi,
                                           lvl_r.omega)

        ## Phi-Newton Polygon

        sides, side_devs = tt.phi_newton_polygon(r, phiadic)
      #  print "Sides of Newton polygon: %s" % (sides,)         
        length_N = lvl_r.omega
        index_N = -lvl_r.cutting_slope * (length_N*(length_N-_sage_const_1 ) // _sage_const_2 )
        starting_prod_f = lvl_r.prod_f
       # print "index N: %d, length N: %d" % (index_N, length_N)
        if length_N == _sage_const_1 :

            tt.add_last_level(phiadic, sides[_sage_const_0 ], side_devs[_sage_const_0 ])

#            print "  #### Found a factor of depth r = %d (%s):\n    %s\n" % (r-1, lvl_r.phi, tt)
            leaves.append(tt)
            sides = []

        # Create copies of tt for each side to use
        if len(sides) > _sage_const_0 :
            side_indexes_types = [(_sage_const_0 , tt)]
            if len(sides) > _sage_const_1 :
                side_indexes_types += [(i, tt.copy()) for i in (ellipsis_range(_sage_const_1 ,Ellipsis,len(sides)-_sage_const_1 ))]
                more_factors = True
            else:
                more_factors = False
            side_indexes_types.reverse()
            print side_indexes_types
        else:
            side_indexes_types = [ ]

        previous_h = _sage_const_0 

        for i, tt in side_indexes_types:
            #for i in reversed([0..len(sides)-1]):
            
            lvl_r = tt.rth_level()
            side = sides[i]
         #   print "Analysing side: %s" % (str(side),)

            lvl_r.h = - side.slope.numerator()
            lvl_r.e = side.slope.denominator()
            lvl_r.slope = - side.slope
            lvl_r.inv_h = inverse_mod(lvl_r.h, lvl_r.e)
            
            lprime = (lvl_r.inv_h*lvl_r.h - _sage_const_1 ) // lvl_r.e
            new_pi = list( lvl_r.inv_h * lvl_r.log_phi - lprime*lvl_r.log_pi )
            new_pi.append(_sage_const_0 )
            lvl_r.log_gamma = lvl_r.e*lvl_r.log_phi - lvl_r.h*lvl_r.log_pi

            #E = ZZ(side[2][0] - side[1][0]) # [2][0] - [1][0]
            #H = ZZ(side[1][1] - side[2][1]) # [1][1] - [2][1]
            E = ZZ(side.width())
            H = ZZ(side.height())
            index_N += (E * previous_h) + ((E*H-E-H+(E // lvl_r.e)) // _sage_const_2 )
       #     print "E: %d, H: %d, side: %s, index N: %d" % (E, H, str(side), index_N,)
            previous_h += H
            ## Residual polynomial
            res_pol = tt.residual_polynomial(r, side_devs[i])
            res_pol = res_pol.monic()
            factors = res_pol.factor()
#            print "Res.Pol. factors: %s" % (list(factors),)
            factors_types = [ (factors[_sage_const_0 ], tt) ]
            if len(factors) > _sage_const_1 :
                factors_types += [ (factors[i], tt.copy()) for i in (ellipsis_range(_sage_const_1 ,Ellipsis,len(factors)-_sage_const_1 )) ]
                more_factors = True

            for factor, tt in factors_types:
          #      print "Analysing factor of the Res.Pol. %s" % (factor[0],)

           #     print 'old_tt:', tt
                lvl_r = tt.rth_level()

                omega = factor[_sage_const_1 ]
                lvl_r.res_pol = factor[_sage_const_0 ]
                lvl_r.f = lvl_r.res_pol.degree()

                ## Representative
                # The new level (lvl_rp1) is already part of the type.
                lvl_rp1 = tt.representative(omega)
  #              print 'new_tt:', tt

                if lvl_r.phi.degree() == lvl_rp1.phi.degree():
                    # Non-optimal, refining level r
#                    print 'Refining, cutting slope: %s' % (str(lvl_rp1.slope),)
                    tt.refinement(more_factors=more_factors)
                else:
                    # Proceeding to higher order
 #                   print 'Proceeding to higher order'
                    
                    tt.log_pi = vector(new_pi)
                    tt.log_phi = -(lvl_rp1.V // lvl_r.e) * lvl_r.log_pi
                    tt.log_phi = vector(list(tt.log_phi) + [_sage_const_1 ])

                # Push the new or refined type onto the stack.
                type_stack.append(tt)
  #              print "after appending to stack: %s" % (str(type_stack),)

            ## End of `factors' for loop
        ## End of `sides' for loop
        
        total_index += starting_prod_f * index_N
#        print "Added %d * %d to the index (--> %d)" % (starting_prod_f, index_N, total_index,)

    return leaves, total_index

def phi_expansion(f, phi, omega):
    q = f
    coeffs = [ ]
    quos = [ ]
    Ax=f.parent()
    for j in (ellipsis_range(_sage_const_0 ,Ellipsis,omega)):
        q, r = q.quo_rem(phi)
        coeffs.append(Ax(r))
        quos.append(Ax(q))

    return coeffs, quos

def path_of_precision(n, h):
    q = n
    path = [ n ]

    while q > h:
        q, a = q.quo_rem(_sage_const_2 )
        q += a
        path.insert(_sage_const_0 , q)

    return path

def change_precision(a, prec):
    if not isinstance(a.parent(), sage.rings.padics.local_generic.LocalGeneric):
        # We assume it's a polynomial.
        return a.parent()([ change_precision(c, prec) for c in a])

    if prec > a.precision_absolute():
        a = a.lift_to_precision(prec)
    else:
        a = a.add_bigoh(prec)

    return a



def index(F):

	f=minimal_polynomial(F.gen(0))
	print"before dsc"
	dsc=f.discriminant().numerator()
	print"after dsc"
	dsc_prime=derivative(dsc)
	facs=list(factor(gcd(dsc,dsc_prime)))
	print"sqr fac"	
	local_index=[]
	for fac in facs:
		om,ind=montes(F,fac[_sage_const_0 ])
		local_index.append(ind*fac[_sage_const_0 ].degree())
	print"out"				
	return sum(local_index)	
	
	
def terms(f):

	x=f.parent().gen(0)
	L=list(f)
	if len(L) == _sage_const_1 :
		return L
		
	tmp=[]
	for i in (ellipsis_range(_sage_const_0 ,Ellipsis,len(L)-_sage_const_1 )):
		tmp.append(L[i]*x**i)
	
	return tmp
	
	

def infinity_representation(F):

	K=F.base_field()
	T=K.gen(0)
	A=T.numerator().parent()
	f=minimal_polynomial(F.gen(0))	
	n=f.degree()
	coeff=[c.numerator() for c in f.coefficients()]
	cf=max([ceil(coeff[j].degree()/(-j+n)) for j in (ellipsis_range(_sage_const_0 ,Ellipsis,len(coeff)-_sage_const_2 ))])
	coeff_list=list(T**(-n*cf)*f.parent()(	f(T**cf*f.parent().gen(0)))	)
	coeff_newf=[];
	for i in coeff_list:
		tmp=_sage_const_0 
		
		for j in terms(i.numerator()):
			j=A(j)
			tmp=tmp+j.leading_coefficient()*T**(i.denominator().degree()-j.degree())
		
		coeff_newf.append(tmp)
		
	f_new=f.parent()(coeff_newf)
	return K.extension(f_new),cf;
	
	
def GENUS(F):
	
	n=F.degree()
	ind=index(F)
	FF,cf=infinity_representation(F)	
	om_inf,inf_ind=montes(FF,F.base_field().gen(0))
	ind_new=-n-inf_ind+Integers()((cf*(n-_sage_const_1 )*n/_sage_const_2 ))-ind;
	return ind_new+_sage_const_1 




	
	
	
	
	
	
