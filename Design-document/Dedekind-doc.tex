\documentclass{amsart}
\usepackage{color} %forcolor
\usepackage{verbatim}
\usepackage{rotating} %for \includegraphix[angle=270]
\usepackage{amssymb}
\usepackage{xypic}

\usepackage{soul}




%%Change to Roman for enumerate
\renewcommand{\labelenumi}{(\roman{enumi})}
\newcommand{\tr}{{ \mathrm{tr}}}

\newcommand{\str}{{ \ \tr}}

\theoremstyle{definition}
\newtheorem*{remark*}{Remark}

%%Expand maximum matrix size
\setcounter{MaxMatrixCols}{20}

%%% Some defintions

\def\p{\mathfrak{p}}
\def\P{\mathfrak{P}}
\def\su{\mathrm{supp}}
\def\oo{\mathcal{O}}
\def\NM{\mathrm{Norm}}





%%%
\usepackage[bookmarks,colorlinks,breaklinks]{hyperref}  % PDF hyperlinks, with coloured links
\hypersetup{linkcolor=blue,citecolor=blue,filecolor=blue,urlcolor=blue} % all blue links

\title{Design document for Function Field Project}
\author{Jens Bauch}
\author{Avi Kulkarni}
\date{\today}

\begin{document}
	
\maketitle

\section{Theoretical Background}

In this section we describe the theoretical framwork for our package (what will be the package name?). 

Let $A$ be a Dedekind domain and $K$ the fraction field of $A$. Denote by $\theta$ a root of a monic irreducible separable polynomial $f\in A[x]$ of degree $n$ and let $L=K(\theta)$ be the algebraic extension defined by $f$. We denote by $\oo_L$ the integral closure of $A$ in $L$. If $A$ is a PID, then $\oo_L$ is a free $A$-module of rank $n$. Any ideal $I$ of $\oo_L$ can alse be consider as a free $A$-module of rank $n$.

In this subsection we summarize the results from \cite{Fieker} in the context of algebraic function fields. Let $I$ be a fractional ideal of $\oo_F$ and $S$ be a set of prime polynomials in $A$ such that the numerator of $\NM(I)$ factors over $S$. We call the pair $(g,\gamma)$ an $S$-normal presentation for $I$ iff
\begin{enumerate}
\item $g$ belongs to $I\cap A$ and $\gamma\in A$,
\item  for all prime ideals $\P$ of $\oo_F$ over $p\notin S$ we have $v_\P(g)=v_P(I)$=0,
\item  for all prime ideals $\P$ of $\oo_F$ over $p\in S$ we have $v_\P(\gamma)=v_P(I)$.
\end{enumerate}

For the multiplication of two ideals $I$ and $I'$ we consider their $S$-normalized presentations $(g,\gamma)$ and $(g',\gamma')$, respectively. Then $(g\cdot g',\gamma\cdot \gamma')$ is an $S$-normal presentations of $I\cdot I'$. We define the $\su(I)$ to be the set of all prime ideals of $\oo_F$ which divide $I$ and set $S(I):=\su_A(I) =\{\P\cap A\mid\P\in\su(I)\}$. In practice we present and ideal by an $S(I)$-normal presentation. Given an $S(I)$-normal presentation of $I$ and an $S(I')$-normalized presentation of $I'$ we have to compute for both ideals an $S=S(I)\cup S(I')$-normal presentation and multiply their components in order to get an $S$-normal presentation $I\cdot I'$. Let $s_I=\prod_{p\in S(I)}p$ and $s_{I'}=\prod_{p\in S(I')\setminus S(I)}p$. If $\gcd(g s_I,s_{I'})=1=ug s_I+vs_{I'}$, then $(g,\delta)$ is an $S$-normal presentation according Lemma 6.3 in \cite{Fieker}, where $\beta = vs_{I'}\gamma+ug s_I$.

For the inversion of $I$, suppose that $a\cdot A = \gamma\oo_F\cap A$, where $a$ factors into $a_1\cdot a_2$ with $a_2$ not divisible by polynomials in $S$. Then $(1,a_2\gamma)$ is an $S(I)$-normal presentation of $I^{-1}$. 

For a principal ideal $I = \langle \gamma\rangle$ an $S(I)$-normal presentation is given by $(g,\gamma)$, where $g= I\cap A$.

In chapter XXX we will analyze the runtime of of the multiplication and Inversion of ideals in $S$-normal presentation. Henceforth we call an $S(I)$-normal presentation of the ideal $I$ just a normal presentation  of $I$.


	
	\section{General Architecture}
	
			As per the manual page regarding the depreciated "Dedekind domain" class, we should implement Dedekind domains as a Sage Category and implement our methods as generic operations whenever possible. Of course, we can always override these methods for specific classes of Dedekind domains, such as with NumberFields.
			
			\bigskip
			
			Why use the category framework:
			\begin{enumerate}
				\item 
					It really does not seem like it is that difficult to use.
				\item
					If our implementations are sufficiently generic, then we do not need to rewrite the class methods every time we want to implement a new type of Dedekind domain.
				\item
					We minimize code duplication.
				\item
					We can augment pre-existing classes in SAGE by refining the category. What sage does is attaches the "ParentMethods" defined in the category to the parent class, "ElementMethods" to the elements, etc. This means, for instance, that the preexisting "AbsoluteOrder" class for number fields can inherit the methods we write without restructuring the entire class hierarchy. Of course, whether these methods compute the correct thing when called can be tricky!
				\end{enumerate}
			
			\begin{remark*}
				We need to be careful regarding the order of inheritance. For instance, the method "\_mul\_" defined for "NumberFieldIdeal" should override the generic category method we write and not vice-versa. To me it is unclear how exactly to do this. For now, we can throw an error if someone tries to turn a "NumberFieldIdeal" into a "DedekindDomainIdeal".
			\end{remark*}
			
			\begin{remark*}
				After implementing the "DedekindDomains" category, in principle we should find all of the Sage Categories for which "DedekindDomains" is an immediate supercategory (basically, PIDS). 
			\end{remark*}
	
			\begin{remark*}
				The Sage Category "NumberFields" implements none of the important routines. Instead, the design decision there was to implement all routines as class methods in "NumberFieldIdeal". This is likely because the original code was written before 2009. That is, before the category framework was in Sage. 
			\end{remark*}
	
	\subsection{Category hierarchies}
	
		An arrow $A \longrightarrow B$ indicates that the category $A$ is a subcategory of $B$.
		
		The following is a piece of Sage's category graph. The dotted arrows shows where our future category resides
		\[
		\xymatrix{
			\ldots \\
			IntegralDomains \ar[u] \\
			GcdDomains \ar[u]   &   DedekindDomains \ar@{-->}[ul] \\
			UFDs \ar[u] \\
			PIDS \ar[u] \ar@{-->}[uur] \\
			\ldots \ar[u] \\
			Fields \ar[u] \\
			QuotientFields \ar[u] &  DedekindDomainQuotientField\_with\_order \ar@{-->}[l] \ar@{-->}[uuuuu]_{temporary} 
		}
		\]
		Note that the reason we might need "DedekindDomainQuotientField\_with\_order" is so that our valuations have somewhere to live. Temporarily, we should declare the immediate super category to be Dedekind domains so we don't have to update the super category list for PIDs. Otherwise, doing things properly, requires us to keep a full Sage source in the git repository.
	
		\hspace{1in}
	
		TODO: It is presently unclear what to do regarding the category structure of ideals of Dedekind domains. One approach is to simply have a class "DedekindDomainIdeal", but modify the category of "DedekindDomains" to have the ideal() method automatically generate a "DedekindDomainIdeal". The other is to make a category of "DedekindDomainIdeals" and implement functionality there. Both methods are likely equivalent for our purposes. We should draw inspiration from the treatment of ideals in the category "PIDs". Ultimately, this decision comes down to what works best with interfacing with the existing operations for "NumberFieldIdeals".
			
	\section{Class hierarchy}
	
	An arrow $A \longrightarrow B$ indicates that the class $A$ inherits from the class $B$.
	
	\begin{remark*}
		The DedekindDomain class is depreciated, but already exists in sage. However, the implementation there seems to be unsubstantial. 
		
		The documentation also recommends the creation of a DedekindDomain \emph{category}. We should probably ask about this. Regardless, it seems like we need to code the class anyways.
	\end{remark*}
	
	\[
		\xymatrix{
			Ideal\_generic \\
			DedekindDomainIdeal \ar[u] & MultiplicativeGroupElement \\
			DedekindDomainFractionalIdeal \ar[ur] \ar[u]
		}
	\]
	
	\section{Classes}

	\subsection{Class/Category: DedekindDomain}: \newline
		
		Attributes:
		\begin{itemize}
			\item 
			Maximal Order
		\end{itemize}
	
		Init:
		\begin{itemize}
			\item
			NumberFields $\rightarrow$ Invoke sage's routines
			\item
			FunctionFields $\rightarrow$ do our things
			\item
			Else $\rightarrow$ NotImplementedError
			\item
			Category: Demand required parent/element methods (valuation, gcd, etc)
		\end{itemize}
	
		Methods:
		\begin{itemize}
			\item 
			FractionalIdealGroup
			\item
			krull\_dimension
			\item
			valuation
		\end{itemize}

	\subsection{Class/Category: DedekindDomainElt}: \newline
	
	Attributes:
	\begin{itemize}
		\item 
		denominator
	\end{itemize}
	
	Init:
	\begin{itemize}
		\item
		NumberFields $\rightarrow$ Invoke sage's routines
		\item
		FunctionFields $\rightarrow$ do our things
		\item
		Else $\rightarrow$ NotImplementedError
	\end{itemize}
	
	Methods:
	\begin{itemize}
		\item
		denominator
		\item
		numerator
	\end{itemize}

	\subsection{Class: DedekindDomainIdeal}: \newline
	
	{\bf Do we want to make the 2-element representation/ OM representation different classes, or do we want the same object to record both representations?} \newline
	
	Attributes:
	\begin{itemize}
		\item 
		Basis
	\end{itemize}
	
	Methods:
	\begin{itemize}
		\item
		is\_prime
		\item
		denominator
		\item
		comparison method
		\item
		mult
		\item
		norm
		\item
		index
		\item
		inertia\_degree
		\item
		ramification\_degree
		\item
		maximal\_order\_basis
		\item
		convert\_to\_OM
			\begin{itemize}
				\item 
				if self is prime, do conversion
				\item
				else raise NotImplementedError
			\end{itemize}
		\item
		convert\_to\_hnf-representation
			\begin{itemize}
				\item 
				Only for number fields
			\end{itemize}
		\item
		$\mathbb{Z}$-basis to 2-elt representation
	\end{itemize}

	\subsection{Class: DedekindDomainFractionalIdeal}: \newline
	
	Attributes:
	\begin{itemize}
		\item 
		Basis
	\end{itemize}
	
	Methods:
	\begin{itemize}
		\item
		is\_integral
		\item
		denominator
		\item
		comparison method
		\item
		mult
		\item
		inver
		\item
		norm
		\item
		index
		\item
		inertia\_degree
		\item
		ramification\_degree
		\item
		convert\_to\_OM
		\begin{itemize}
			\item 
			if self is prime, do conversion
			\item
			else raise NotImplementedError
		\end{itemize}
		\item
		convert\_to\_hnf-representation
		\begin{itemize}
			\item 
			Only for number fields
		\end{itemize}
	\end{itemize}

\section{Accessory functions}

\section{TODO}

\begin{enumerate}
	\item
		Decide if 2-elt/OM representations should be distinct classes or unified in a single class
	\item
		\st{ Decide on Category versus Object approach for Dedekind Domains} We should use the Category approach.
	\item
		Decide on Category or Object approach for DedekindDomainIdeals
	\item
		Determine useful information to store as attributes
\end{enumerate}


\end{document}

